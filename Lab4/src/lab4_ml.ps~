%!PS-Adobe-3.0
%%Title: lab4_ml.c
%%For: Manuel Lopez
%%Creator: a2ps version 4.14
%%CreationDate: Fri Nov 15 16:18:10 2019
%%BoundingBox: 24 24 588 768
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 6
%%PageOrder: Ascend
%%DocumentMedia: Letter 612 792 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontType get 0 eq {
    currentfont /FontMatrix get 3 get
  }{
    currentfont /FontMatrix get 3 get 1000 mul
  } ifelse
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      % <vector> <key> <val>
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def % -

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Get the underline position and thickness if they're defined.
    % Use 1 if they are not defined.
    currentdict /FontInfo 2 copy known
    { get
      /UnderlinePosition 2 copy % <FontInfo> /UP <FontInfo> /UP
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>

      /UnderlineThickness 2 copy % <FontInfo> /UT <FontInfo> /UT
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>
      pop % -
    }{ pop pop
    } ifelse

    currentdict
  end 
} bind def

% composite fonts for ASCII-EUC mixed strings
% Version 1.2 1/31/1990
% Original Ken'ichi HANDA (handa@etl.go.jp)
% Modified Norio Katayama (katayama@rd.nacsis.ac.jp),1998
% Extend & Fix Koji Nakamaru (maru@on.cs.keio.ac.jp), 1999
% Anyone can freely copy, modify, distribute this program.

/copyfont {	% font-dic extra-entry-count  copyfont  font-dic
	1 index maxlength add dict begin
	{	1 index /FID ne 2 index /UniqueID ne and
		{def} {pop pop} ifelse
	} forall
	currentdict
	end
} bind def

/compositefont { % ASCIIFontName EUCFontName RomanScale RomanOffset Rot(T/F) compositefont font
    /RomanRotation exch def
    /RomanOffset exch def
    /RomanScale exch def
    userdict /fixeucfont_dict known not {
	userdict begin
	    /fixeucfont_dict 2 dict begin
		/UpperByteEncoding [
		    16#00 1 16#20 { pop 0 } for
		    16#21 1 16#28 { 16#20 sub } for
		    16#29 1 16#2F { pop 0 } for
		    16#30 1 16#74 { 16#27 sub } for
		    16#75 1 16#FF { pop 0 } for
		] def
	        /LowerByteEncoding [
		    16#00 1 16#A0 { pop /.notdef } for
		    16#A1 1 16#FE { 16#80 sub 16 2 string cvrs
				    (cXX) dup 1 4 -1 roll
				    putinterval cvn } for
		    /.notdef
		] def
		currentdict
	    end def
	end
    } if
    findfont dup /FontType get 0 eq {
	14 dict begin
	    %
	    % 7+8 bit EUC font
	    %
	    12 dict begin
		/EUCFont exch def
		/FontInfo (7+8 bit EUC font) readonly def
		/PaintType 0 def
		/FontType 0 def
		/FontMatrix matrix def
		% /FontName
		/Encoding fixeucfont_dict /UpperByteEncoding get def
		/FMapType 2 def
		EUCFont /WMode known
		{ EUCFont /WMode get /WMode exch def }
		{ /WMode 0 def } ifelse
		/FDepVector [
		    EUCFont /FDepVector get 0 get
		    [ 16#21 1 16#28 {} for 16#30 1 16#74 {} for ]
		    {
			13 dict begin
			    /EUCFont EUCFont def
			    /UpperByte exch 16#80 add def	
			    % /FontName
			    /FontInfo (EUC lower byte font) readonly def
			    /PaintType 0 def
			    /FontType 3 def
			    /FontMatrix matrix def
			    /FontBBox {0 0 0 0} def
			    /Encoding
				fixeucfont_dict /LowerByteEncoding get def
			    % /UniqueID
			    % /WMode
			    /BuildChar {
				gsave
				exch dup /EUCFont get setfont
				/UpperByte get
				2 string
				dup 0 4 -1 roll put
				dup 1 4 -1 roll put
				dup stringwidth setcharwidth
				0 0 moveto show
				grestore
			    } bind def
			    currentdict
			end
			/lowerbytefont exch definefont
		    } forall
		] def
		currentdict
	    end
	    /eucfont exch definefont
	    exch
	    findfont 1 copyfont dup begin
		RomanRotation {
			/FontMatrix FontMatrix
			[ 0 RomanScale neg RomanScale 0 RomanOffset neg 0 ]
			matrix concatmatrix def
		}{
			/FontMatrix FontMatrix
			[ RomanScale 0 0 RomanScale 0 RomanOffset ] matrix concatmatrix
			def
			/CDevProc
			    {pop pop pop pop 0 exch -1000 exch 2 div 880} def
		} ifelse
	    end
	    /asciifont exch definefont
	    exch
	    /FDepVector [ 4 2 roll ] def
	    /FontType 0 def
	    /WMode 0 def
	    /FMapType 4 def
	    /FontMatrix matrix def
	    /Encoding [0 1] def
	    /FontBBox {0 0 0 0} def
%	    /FontHeight 1.0 def % XXXX
	    /FontHeight RomanScale 1.0 ge { RomanScale }{ 1.0 } ifelse def
	    /Descent -0.3 def   % XXXX
	    currentdict
	end
	/tmpfont exch definefont
	pop
	/tmpfont findfont
    }{
	pop findfont 0 copyfont
    } ifelse
} def	

/slantfont {	% FontName slant-degree  slantfont  font'
    exch findfont 1 copyfont begin
    [ 1 0 4 -1 roll 1 0 0 ] FontMatrix exch matrix concatmatrix
    /FontMatrix exch def
    currentdict
    end
} def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 612 def
/sw 792 def
/llx 24 def
/urx 768 def
/ury 588 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 7.493857 def
/cw 4.496314 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   522.321860 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(//Author: Jose Manuel Lopez Alcala) c n
(//ID:932503918) N
(//ECE 473 Lab4) N
(//Fall 2019) N
(#include) K
( <avr/io.h>) p n
(#include) K
( <util/delay.h>) p n
(#include) K
( <avr/interrupt.h>) p n
(#include) K
( <math.h>) p n
(#include) K
( ") p
(hd44780.h) str
(") p n
() N
(//Bit Macros) c n
(#define) K
( BIT0 0) p n
(#define) K
( BIT1 1) p n
(#define) K
( BIT2 2) p n
(#define) K
( BIT3 3) p n
(#define) K
( BIT4 4) p n
(#define) K
( BIT5 5) p n
(#define) K
( BIT6 6) p n
(#define) K
( BIT7 7) p n
() N
(//Decoder Macros) c n
(#define) K
( SH_LD 6) p n
(#define) K
( CLK_INH 7) p n
() N
(//Encoder 1 values) c n
(volatile) K
( uint8_t encoder1_past = 0;) p n
(volatile) K
( uint8_t encoder1_present =0;) p n
(//Encoder 2 value) c n
(volatile) K
( uint8_t encoder2_past = 0;) p n
(volatile) K
( uint8_t encoder2_present = 0;) p n
(//seconds counter variable) c n
(volatile) K
( uint8_t sec_count=0;) p n
(//minutes counter variable) c n
(volatile) K
( ) p
(int) k
(8_t min_count=0;) p n
(//Military time hours counter variable) c n
(volatile) K
( ) p
(int) k
(8_t hrs_mil=0;) p n
(//Standard time hours counter variabble) c n
(volatile) K
( ) p
(int) k
(8_t hrs_std =12;) p n
(//Bool value for military time vs standard \(1=standard/0=military\)) c n
(volatile) K
( uint8_t mil_std = 0x00;) p n
(//Parsed time variables) c n
(volatile) K
( uint8_t min_ones =0;) p n
(volatile) K
( uint8_t min_tens =0;) p n
(volatile) K
( uint8_t hrs_ones =0;) p n
(volatile) K
( uint8_t hrs_tens =0;) p n
(//holds data to be sent to the segments. logic zero turns segment on) c n
(volatile) K
( uint8_t segment_data[5];) p n
(//hold adc result) c n
(volatile) K
( uint16_t adc_result;) p n
(//Mode Variables) c n
(volatile) K
( uint8_t mode =0;) p n
(volatile) K
( uint8_t inc_dec1 = 1;) p
(//for decoder 1) c n
(volatile) K
( uint8_t inc_dec2 = 1;) p
(// for decoder 2) c n
(//dummy counter variable\(for loop\) in update_mode\(\)) N
(volatile) K
( uint8_t n = 0;) p n
(//PORTC previous values) c n
(volatile) K
( uint8_t PORTC_previous = 0;) p n
(//PORTA previous value) c n
(volatile) K
( uint8_t PORTA_previous = 0;) p n
(//bit counter varibale for "cleaning" encoder data) c n
(volatile) K
( uint8_t bitn = 0;) p n
(//reset bool variable) c n
(volatile) K
( uint8_t reset =1;) p
(// true when first start up) c n
(//encoder value) N
(volatile) K
( uint8_t encoder_val = 0;) p n
(//Alarm Variables) c n
(volatile) K
( ) p
(int) k
(8_t a_hrs_mil = 0;) p
(//initialize to 7) c n
(volatile) K
( ) p
(int) k
(8_t a_hrs_std = 0;) p
(//initialize to 7) c n
(volatile) K
( ) p
(int) k
(8_t a_min_count = 1;) p
(//initialize to 0) c n
(lab4_ml.c) (Page 1/12) (Nov 15, 19 16:17) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(volatile) K
( uint8_t a_min_ones =0;) p n
(volatile) K
( uint8_t a_min_tens =0;) p n
(volatile) K
( uint8_t a_hrs_ones =0;) p n
(volatile) K
( uint8_t a_hrs_tens =0;) p n
(//String for lcd) c n
(char) k
( lcd_string_on[16] = ") p
(ALARM) str
(";) p n
(//variable to hold snooze time in seconds) c n
(volatile) K
( uint16_t snooze_time =10;) p n
(//variable that indicates snoozing) c n
(uint8_t snoozing = 0;) p n
(//Alarm sound on variable) c n
(volatile) K
( uint8_t alarm_sound = 0;) p n
(//Update LCD flag) c n
(volatile) K
( uint8_t lcd_flag =0;) p n
(//OCR2 value holder) c n
(volatile) K
( ) p
(int) k
(16_t ocr2_value = 0;) p n
() N
() N
(//******************************************************************************) c n
(//                            debounce_switch) N
(//Checks the state of the button number passed to it. It shifts in ones till) N
(//the button is pushed. Function returns a 1 only once per debounced button) N
(//push so a debounce and toggle function can be implemented at the same time.) N
(//Adapted to check all buttons from Ganssel's "Guide to Debouncing") N
(//Expects active low pushbuttons on PINA port.) N
(//) N
(uint8_t debounce_switch\(uint8_t pin\) {) p n
(  ) S
(static) K
( uint16_t state[8] = {0};) p n
(  state[pin] = \(state[pin]<<1\)|\(!bit_is_clear\(PINA,pin\)\)|0xE000;) N
(  ) S
(if) K
( \(state[pin]==0xF000\) {) p n
(    ) S
(return) K
( 1;) p n
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
(/***************************************************************) c n
(Function: update_lcd\(\)) N
(Description:) N
(  This function will update the LCD display based on whether) N
(  or not the alarm is armed) N
(Parameters: NONE) N
(Return:void) N
(***************************************************************/) N
(void) k
( update_lcd\(\){) p n
(  clear_display\(\);) N
(  cursor_home\(\);) N
(  ) S
(if) K
( \(\(\(mode>>BIT3\)&1\)==1\) {) p
(//Check Alarm EN bit) c n
(    string2lcd\(lcd_string_on\);) p
(//write alarm to the LCD) c n
(  }) p n
(  lcd_flag = 0;) S
(//reset flag) c n
(}) p n
() N
() N
(//***********************************************************************) c n
(//                           init_tcnt0) N
(//***********************************************************************) N
(//initalize timer/counter zero to normal mode) N
(void) k
( init_tcnt0\(\){) p n
(  ASSR  |= \(1<<AS0\);) S
(//run off external 32kHz osc) c n
(  TIMSK |= \(1<<TOIE0\);) p
(//overflow interrup) c n
(  TCCR0 |= \(1<<CS00\);) p
(//Normal mode, no prescale) c n
(}) p n
() N
() N
() N
(//***********************************************************************) c n
(//                           init_tcnt2) N
(//***********************************************************************) N
(void) k
( init_tcnt2\(\){) p n
(  ) S
(//Fast PWM, Non-inverting mode on OC2\(PB7\),CLKio/1024 prescale, uC clock) c n
(lab4_ml.c) (Page 2/12) (Nov 15, 19 16:17) title
border
grestore
(Printed by Manuel Lopez) rhead
(lab4_ml.c) (1/6) (Friday November 15, 2019) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  TCCR2 |= \(1<<WGM21\)|\(1<<WGM20\)|\(1<<COM21\)|\(1<<COM20\)|\(0<<CS20\)|\(0<<CS21\)|\(1<<C) p n
(S22\);) N
(  TIMSK |= \(1<<TOIE2\);) S
(//overflow interrupt) c n
(  OCR2  |= 127;) p
(//initalize to half of the total scale \(0-255\)) c n
() p n
(}) N
() N
(//***********************************************************************) c n
(//                           init_tcnt3) N
(//***********************************************************************) N
(void) k
( init_tcnt3\(\){) p n
(  ) S
(//Non-inverting mode //FAST PWM, 8-bit, no prescale) c n
(  TCCR3A |= \(1<<COM3A1\)|\(0<<COM3A0\)|\(0<<WGM31\)|\(1<<WGM30\);) p n
(  TCCR3B |= \(0<<WGM33\)|\(1<<WGM32\)|\(1<<CS30\);) N
(  OCR3A =  127;) S
(//Vout = OCR3A*\(0.0198\)+0.022) c n
(}) p n
() N
(//***********************************************************************) c n
(//                           init_tcnt1) N
(//***********************************************************************) N
(void) k
( init_tcnt1\(\){) p n
(  ) S
(//CTC mode,no prescale, Normal port operation) c n
(  TCCR1B |= \(1<<WGM12\)|\(1<<CS10\);) p n
(  TIMSK  |= \(1<<OCIE1A\);) S
(// Output compare A match) c n
(  OCR1A   = 0x1F3F;) p
(//7999 for 1Khz wave) c n
(  ) p
(//OCR1A   = 0xF9F;//3999 for 2Khz wave) c n
(  ) p
(//OCR1A   = 0x3E7F;//15999 for 500Khz wave) c n
() p n
(}) N
() N
(// //***********************************************************************) c n
(// //                     ISR for timer counter one) N
(// //***********************************************************************) N
(ISR\(TIMER1_COMPA_vect\){) p n
(  ) S
(static) K
( uint16_t count_isr1 = 0;) p n
(  ) S
(static) K
( uint8_t lcd_counter = 0;) p n
(  lcd_counter++;) N
(  count_isr1++;) N
() N
(  ) S
(if) K
( \(lcd_flag ==1 \) {) p
(//only update when bit toggled) c n
(    update_lcd\(\);) p n
(  }) N
() N
(  ) S
(if) K
( \(\(\(mode>>BIT3\)&1\) == 1\) {) p
(// Check Alarm enabled bit) c n
(    ) p
(if) K
( \(\(hrs_mil == a_hrs_mil\)&&\(min_count == a_min_count\)\) {) p
(//current time matc) c n
(hes alarm time) N
(      alarm_sound = 1;) p
(//Alarm sound on) c n
(    }) p n
() N
(    ) S
(if) K
( \(\(\(\(mode>>BIT4\)&1\)==1\)&&\(alarm_sound==1\)\) {) p
(//check Snooze enabled bit and) c n
( alarm is on) N
(      snoozing =1;) p
(//activate snoozing) c n
(      mode &= ~\(1<<BIT4\);) p
(//clear snooze bit) c n
(      count_isr1 = 0;) p
(//reset count ready for snoozing) c n
(    }) p n
() N
(    ) S
(if) K
( \(snoozing == 1\) {) p
(//system is snoozing) c n
(      alarm_sound = 0;) p
(//Alarm sound off) c n
(      ) p
(if) K
( \(count_isr1 == 2000\) {) p
(//1 second tick) c n
(        snooze_time--;) p
(//decrement snooze time) c n
(        count_isr1 =0;) p
(//reset count) c n
(        ) p
(if) K
( \(snooze_time==0\) {) p n
(          alarm_sound = 1;) S
(//Alarm sound ON) c n
(          snooze_time = 10;) p
(//reset snooze time) c n
(          snoozing    = 0;) p
(//reset snoozing) c n
(        }) p n
(      }) N
(    }) N
() N
(lab4_ml.c) (Page 3/12) (Nov 15, 19 16:17) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(if) K
( \(alarm_sound==1\) {) p n
(      PORTD ^= \(1<<BIT0\);) S
(//toggle Pin 0 on Port d for alarm sound) c n
(    }) p n
(  }) S
(else) K
({) p n
(    mode &= ~\(1<<BIT4\);) S
(// clear snooze if Alarm DISABLED) c n
(    alarm_sound=0;) p
(//alarm souund off) c n
(  }) p n
(}) N
() N
() N
() N
(/***************************************************************) c n
(Function: update_time\(\)) N
(Description:) N
(  This function will update the time based on the current second) N
(  count) N
(Parameters: NONE) N
(Return: void) N
(***************************************************************/) N
(void) k
( update_time\(\) {) p n
(  ) S
(if) K
( \(sec_count == 59\) {) p n
(    sec_count =0;) S
(//reset seconds) c n
(    ) p
(if) K
( \(min_count==59\) {) p n
(      min_count=0;) S
(//reset mins) c n
(      ) p
(if) K
( \(hrs_mil==23\) {) p n
(        hrs_mil =0;) S
(//reset military time) c n
(      }) p
(else) K
({) p n
(        hrs_mil++;) S
(//increment military time) c n
(      }) p n
(      ) S
(if) K
( \(hrs_std == 13\) {) p n
(        hrs_std =1;) S
(//reset standard time) c n
(      }) p
(else) K
({) p n
(        hrs_std++;) S
(//increment standard time) c n
(      }) p n
(    }) S
(else) K
({) p n
(      min_count++;) S
(//increment min count) c n
(    }) p n
(  }) S
(else) K
({) p n
(    sec_count++;) S
(//increment seconds) c n
(  }) p n
(}) N
() N
(/***************Function: decoder\(\)***************************) c n
(Description:) N
(  Takes in an 8 bit decimal and returns the binary equivalent) N
(  that will be used to display on the seven segement.) N
(  Format:\(DP\)GFEDCBA) N
(Parameters:) N
(  - uint8_t decimal: This is the decimal that needs to be converted) N
(Precondition: NONE) N
(Return: uint_t binary equivalent) N
(************************************************************************/) N
(uint8_t decoder\(uint8_t decimal\)) p n
({) N
(  ) S
(if) K
( \(decimal == 0\) {) p
(//decimal: 0) c n
(    ) p
(return) K
( 0b11000000;) p n
(  }) S
(else) K
( ) p
(if) K
( \(decimal == 1\) {) p
(//decimal: 1) c n
(    ) p
(return) K
( 0b11111001;) p n
(  }) S
(else) K
( ) p
(if) K
( \(decimal == 2\) {) p
(//decimal: 2) c n
(    ) p
(return) K
( 0b10100100;) p n
(  }) S
(else) K
( ) p
(if) K
( \(decimal == 3\) {) p
(//decimal: 3) c n
(    ) p
(return) K
( 0b10110000;) p n
(  }) S
(else) K
( ) p
(if) K
( \(decimal == 4\) {) p
(//deciaml: 4) c n
(    ) p
(return) K
( 0b10011001;) p n
(  }) S
(else) K
( ) p
(if) K
( \(decimal == 5\) {) p
(//decimal: 5) c n
(    ) p
(return) K
( 0b10010010;) p n
(  }) S
(else) K
( ) p
(if) K
( \(decimal == 6\) {) p
(//deciaml: 6) c n
(    ) p
(return) K
( 0b10000010;) p n
(  }) S
(else) K
( ) p
(if) K
( \(decimal == 7\) {) p
(//decimal: 7) c n
(lab4_ml.c) (Page 4/12) (Nov 15, 19 16:17) title
border
grestore
(Printed by Manuel Lopez) rhead
(lab4_ml.c) (2/6) (Friday November 15, 2019) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(return) K
( 0b11111000;) p n
(  }) S
(else) K
( ) p
(if) K
( \(decimal == 8\) {) p
(//decimal: 8) c n
(    ) p
(return) K
( 0b10000000;) p n
(  }) S
(else) K
( ) p
(if) K
( \(decimal == 9\) {) p
(//decimal: 9) c n
(    ) p
(return) K
( 0b10010000;) p n
(  }) N
(  ) S
(//should never reach this return) c n
(  ) p
(return) K
( 0b11111111;) p
(// All segments OFF) c n
(}) p n
() N
(/***************************************************************) c n
(Function: adc_init\(\)) N
(Description:) N
(  This function will setup the Analog-to-digital conveter) N
(Parameters: NONE) N
(Return: void) N
(***************************************************************/) N
(void) k
( adc_init\(\){) p n
(  DDRF  &= ~\(_BV\(DDF7\)\);) S
(//make port F bit 7 is ADC input) c n
(  PORTF &= ~\(_BV\(PF7\)\);) p
(// port F bit 7 pullups must be off) c n
(  ADMUX |= \(1<<REFS0\)|\(1<<MUX2\)|\(1<<MUX1\)|\(1<<MUX0\) ;) p
(//single-ended, input PORTF) c n
( bit 7, right adjusted, 10 bits) N
(  ADCSRA|= \(1<<ADEN\)|\(1<<ADPS2\)|\(1<<ADPS1\)|\(1<<ADPS0\);) p
(//ADC enabled, division fa) c n
(ctor 128) N
(}) p n
() N
(/***************************************************************) c n
(Function: adc_read\(\)) N
(Description:) N
(  This function will read the adc and return a 16 bit adc result) N
(Parameters: NONE) N
(Return:) N
(  * 16 bit unsigned  adc result) N
(***************************************************************/) N
(uint16_t adc_read\(\){) p n
(  ADCSRA |= \(1<<ADSC\);) S
(//Start ADC) c n
(  ) p
(while) K
( \(bit_is_clear\(ADCSRA,ADIF\)\){}) p
(//wait for ADC to finish) c n
(  ADCSRA |= \(1<<ADIF\);) p
(//clear flag by writing one) c n
(  ) p
(return) K
( ADC;) p n
(}) N
() N
() N
(/***************************************************************) c n
(Function: decode_time\(\)) N
(Description:) N
(  Parases the value of time to the BCD segment code in the array) N
(  segment_data for display. It also takes care of the PM/AM signaling) N
(  by setting L3 LED on \(bit 2 low \). Lastly, it also shows the) N
(  "ALARM" enable on the DP of mins one segment) N
(Parameters: NONE) N
(Return: void) N
(***************************************************************/) N
(void) k
( decode_time\(\)) p n
({) N
() N
(  ) S
(// Parse Clock time to segment array) c n
(  ) p
(if) K
( \(\(\(mode>>BIT1\)&1\)==0\) {) p n
(    min_ones = \(min_count%10\);) S
(//parsed ones place of minutes) c n
(    min_tens = \(min_count/10\)%10;) p
(//parsed tens place of minutes) c n
() p n
(    ) S
(if) K
( \(mil_std == 0\) {) p
(//military time) c n
(      hrs_ones = \(hrs_mil%10\);) p
(//parse ones) c n
(      hrs_tens = \(hrs_mil/10\)%10;) p
(//parse tens) c n
(      segment_data[2] |= \(1<<BIT2\);) p
(//AM indicator) c n
(    }) p
(else) K
({) p
(//standard time) c n
(      hrs_ones = \(hrs_std%10\);) p
(//parse ones) c n
(      hrs_tens = \(hrs_std/10\)%10;) p
(//parse tens) c n
(      ) p
(if) K
( \(hrs_mil>=12\) {) p n
(        segment_data[2] &= ~\(1<<BIT2\);) S
(//PM indicator) c n
(lab4_ml.c) (Page 5/12) (Nov 15, 19 16:17) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      }) p
(else) K
({) p n
(        segment_data[2] |= \(1<<BIT2\);) S
(//AM indicator) c n
(      }) p n
(    }) N
() N
(    ) S
(//decoded numbers to array) c n
(    segment_data[0] = decoder\(hrs_tens\);) p
(//hours tens) c n
(    segment_data[1] = decoder\(hrs_ones\);) p
(//hours ones) c n
(    segment_data[3] = decoder\(min_tens\);) p
(//minutes tens) c n
(    segment_data[4] = decoder\(min_ones\);) p
(//minutes ones) c n
(  }) p
(else) K
( ) p
(if) K
( \(\(\(mode&1\)==0\) && \(\(\(mode>>BIT1\)&1\)==1\)\) {) p
(//parse Alarm time to segem) c n
(t array) N
(    a_min_ones = \(a_min_count%10\);) p
(//parsed ones place of minutes) c n
(    a_min_tens = \(a_min_count/10\)%10;) p
(//parsed tens place of minutes) c n
() p n
(    ) S
(if) K
( \(mil_std == 0\) {) p
(//military time) c n
(      a_hrs_ones = \(a_hrs_mil%10\);) p
(//parse ones) c n
(      a_hrs_tens = \(a_hrs_mil/10\)%10;) p
(//parse tens) c n
(      segment_data[2] |= \(1<<BIT2\);) p
(//AM indicator) c n
(    }) p
(else) K
({) p
(//standard time) c n
(      a_hrs_ones = \(a_hrs_std%10\);) p
(//parse ones) c n
(      a_hrs_tens = \(a_hrs_std/10\)%10;) p
(//parse tens) c n
(      ) p
(if) K
( \(a_hrs_mil>=12\) {) p n
(        segment_data[2] &= ~\(1<<BIT2\);) S
(//PM indicator) c n
(      }) p
(else) K
({) p n
(        segment_data[2] |= \(1<<BIT2\);) S
(//AM indicator) c n
(      }) p n
(    }) N
() N
(    ) S
(//decoded numbers to array) c n
(    segment_data[0] = decoder\(a_hrs_tens\);) p
(//hours tens) c n
(    segment_data[1] = decoder\(a_hrs_ones\);) p
(//hours ones) c n
(    segment_data[3] = decoder\(a_min_tens\);) p
(//minutes tens) c n
(    segment_data[4] = decoder\(a_min_ones\);) p
(//minutes ones) c n
(  }) p n
(  ) S
(if) K
( \(\(\(mode>>BIT3\)&1\)==1\) {) p n
(    segment_data[4] &= ~\(1<<BIT7\);) S
(//ALARM EN indicator) c n
(  }) p
(else) K
({) p n
(    segment_data[4] |= \(1<<BIT7\);) S
(//ALARM DISABLE) c n
(  }) p n
() N
(}) N
() N
() N
() N
(//***********************************************************************) c n
(//                     ISR for timer counter zero) N
(//***********************************************************************) N
(ISR\(TIMER0_OVF_vect\)) p n
({) N
(  ) S
(static) K
( uint8_t count_isr = 0;) p n
(  count_isr++;) N
() N
(  ) S
(if) K
( \(\(count_isr%16\)==0\) {) p n
(    adc_result = adc_read\(\);) S
(//read adc) c n
(    ocr2_value = 0.457*adc_result+5.69;) p
(//calculate new ocr2) c n
(    ) p
(//bound ocr2_value to 0-255) c n
(    ) p
(if) K
( \(ocr2_value<70\) {) p n
(      ocr2_value = 70;) N
(    }) S
(else) K
( ) p
(if) K
( \(ocr2_value>255\) {) p n
(      ocr2_value = 255;) S
(//) c n
(    }) p n
(    OCR2 = ocr2_value;) S
(//set new OCR2) c n
(  }) p n
() N
(  ) S
(if) K
( \(\(count_isr % 128\) == 0\) {) p n
(    update_time\(\);) S
(//update seconds, minutes and hours) c n
(    segment_data[2] ^= \(1<<BIT0\)|\(1<<BIT1\);) p
(//Toggle colon) c n
(  }) p n
(lab4_ml.c) (Page 6/12) (Nov 15, 19 16:17) title
border
grestore
(Printed by Manuel Lopez) rhead
(lab4_ml.c) (3/6) (Friday November 15, 2019) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(}) N
() N
(/***************************************************************) c n
(Function: update_inc_dec\(\)) N
(Description:) N
(  This function will update the increase and decrese value according) N
(  to the mode that has been selected by the user.) N
(Parameters: NONE) N
(Return:void) N
(***************************************************************/) N
(void) k
( update_inc_dec\(\){) p n
(  ) S
(if) K
( \(mode == 0\) {) p
(// increas/decrease 0\(default\)) c n
(    inc_dec1 = 0;) p n
(    inc_dec2 = 0;) N
(  }) S
(else) K
( ) p
(if) K
( \( \(\(mode&1\)==1\) && \(\(\(mode>>1\)&1\)==0\) \) {) p
(//set clock time) c n
(    inc_dec1 = 1;) p n
(    inc_dec2 = 1;) N
(  }) S
(else) K
( ) p
(if) K
( \( \(\(mode&1\)==0\) && \(\(\(mode>>1\)&1\)==1\) \) {) p
(//set alarm time) c n
(    inc_dec1 = 1;) p n
(    inc_dec2 = 1;) N
(  }) S
(else) K
( ) p
(if) K
( \( \(\(mode&1\)==1\) && \(\(\(mode>>1\)&1\)==1\) \) {) p
(//both modes are set) c n
(    inc_dec1 = 0;) p
(//do nothing) c n
(    inc_dec2 = 0;) p
(//do nothing) c n
(  }) p n
(}) N
() N
(/***************************************************************) c n
(Function: update_mode\(\)) N
(Description:) N
(  This function will upate the mode of the system by reading the) N
(  calling the debounce_switch\(\) function and then toggling a bit) N
(  in variable that will be used to determine what the user has selected.) N
(  Register arrangment:) N
(  BIT7\(0\)|BIT6\(0\)|BIT5\(0\)|BIT4\(0\)|BIT3\(Alarm 0/1\)|BIT2\(Mil/STD\)|BIT1\(Alarm Time\)) N
(|BIT0\(Clk Time\)) N
(Parameters: NONE) N
(Return:void) N
(***************************************************************/) N
(void) k
( update_mode\(\) {) p n
(  ) S
(//Reconfigure the PORTS to read from the pushbuttons:) c n
(  DDRA = 0x00;) p
(//set PORT A to all inputs) c n
(  PORTA = 0xFF;) p
(//set PORTA all pullups) c n
(  PORTC = 0x70;) p
(// ENABLE TRI buffer) c n
() p n
(  ) S
(for) K
(\(n = 0; n<=4;n++\){) p
(//only check button 0,1,2,3,4) c n
(    ) p
(if) K
( \(debounce_switch\(n\)\) {) p n
(      ) S
(if) K
( \(n == 0\) {) p
(//button 0) c n
(        mode ^= \(1<<BIT0\);) p
(//Set time \(toggle bit 0\)) c n
(      }) p
(else) K
( ) p
(if) K
( \(n==1\) {) p
(//button 1) c n
(        mode ^= \(1<<BIT1\);) p
(//Set Alarm time \(toggle bit 1\)) c n
(      }) p
(else) K
( ) p
(if) K
( \(n==2\) {) p
(//button 2) c n
(        mode ^= \(1<<BIT2\);) p
(//Toggle Military/Standard) c n
(      }) p
(else) K
( ) p
(if) K
( \(n==3\) {) p n
(        mode ^= \(1<<BIT3\);) S
(//Alarm EN) c n
(        lcd_flag =1;) p
(//set flag to update lcd) c n
(      }) p
(else) K
( ) p
(if) K
( \(n==4\) {) p n
(        mode |= \(1<<BIT4\);) S
(//Set snooze EN \(DON'T Toggle\)) c n
(      }) p n
(    }) N
(  }) N
(  update_inc_dec\(\);) S
(//update the inc/dec varible) c n
(  PORTC = 0x60;) p
(//DISABLE Tri buffer) c n
(}) p n
() N
(/***************************************************************) c n
(Function: spi_read\(\)) N
(Description:) N
(  This function will read the SPI buffer and return the 8bit value) N
(lab4_ml.c) (Page 7/12) (Nov 15, 19 16:17) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(Parameters: NONE) c n
(Return:) N
(  uint8_t value that contains the value of SPDR register) N
(***************************************************************/) N
( uint8_t spi_read\() p
(void) k
(\)) p n
({) N
(  SPDR = 0x00;) S
(//Send dummy data  to be able read register) c n
(  ) p
(while) K
( \(bit_is_clear\(SPSR,SPIF\)\) {}) p
(//wait until it is done.) c n
(  ) p
(return) K
(\(SPDR\);) p
(//return the value of the read data the came in) c n
(}) p n
() N
(/***************************************************************) c n
(Function: read_encoders\(\)) N
(Description:) N
(  This function will read the input of the encoder and increment) N
(  or decrement the count  accordingly) N
(Parameters: NONE) N
(Return:void) N
(***************************************************************/) N
(void) k
( read_encoders\(\){) p n
(  PORTE ^= \(1<<SH_LD\);) S
(//toggle to low) c n
(  PORTE ^= \(1<<SH_LD\);) p
(//toggle back to high) c n
(  PORTE ^= \(1<<CLK_INH\);) p
(//toggle to low) c n
(  encoder_val= spi_read\(\);) p n
(  PORTE ^= \(1<<CLK_INH\);) S
(//toggle to high) c n
() p n
(  ) S
(//"clean" encoder1 value) c n
(  encoder1_present = encoder_val;) p n
(  ) S
(for) K
( \( bitn = 7; bitn > 1; bitn--\) {) p n
(    encoder1_present &= ~\(1<<bitn\);) N
(  }) N
(  ) S
(//"clean" encoder2 value) c n
(  encoder2_present = \(encoder_val>>2\);) p
(//RS so that we get rid bit 0:1) c n
(  ) p
(for) K
( \( bitn = 7; bitn > 1; bitn--\) {) p n
(    encoder2_present &= ~\(1<<bitn\);) N
(  }) N
() N
(  ) S
(if) K
( \(reset == 1\) {) p n
(    encoder1_past = encoder1_present;) S
(//set them equal) c n
(    encoder2_past = encoder2_present;) p
(//set them equal) c n
(    reset = 0;) p
(//set to zero after first time) c n
(  }) p n
() N
(  ) S
(//Update for encoder1 \(corse/ every locking position\)) c n
(  ) p
(//This updates HOURS) c n
(  ) p
(switch) K
( \(encoder1_present\) {) p n
(    ) S
(case) K
( 1:) p
(//encoder value is 01) c n
(      ) p
(if) K
( \(encoder1_past == 0\) {) p
(//past state 00) c n
(        encoder1_past = encoder1_present;) p
(//set current state as past state) c n
(      }) p
(else) K
( ) p
(if) K
( \(encoder1_past == 3 \) {) p
(//past state 11) c n
(        encoder1_past = encoder1_present;) p
(//set current state as past state) c n
(      }) p n
(      ) S
(break) K
(;) p n
(    ) S
(case) K
( 3:) p
(//encoder value is 11) c n
(      ) p
(if) K
( \(encoder1_past == 1\) {) p
(//past state 01) c n
(        ) p
(if) K
( \( \(\(mode&1\)==1\) && \(\(\(mode>>1\)&1\)==0\) \) {) p
(//Clock time) c n
(          hrs_mil += inc_dec2;) p
(//incremetn hours military) c n
(          hrs_std += inc_dec2;) p
(//increment hours standard) c n
(          ) p
(if) K
( \(hrs_mil == 24\) {) p n
(            hrs_mil = 0;) S
(//reset military time hours) c n
(          }) p n
(          ) S
(if) K
( \(hrs_std == 13\) {) p n
(            hrs_std = 1;) S
(//reset standard time hours) c n
(          }) p n
(        }) S
(else) K
( ) p
(if) K
( \(\(\(mode&1\)==0\) && \(\(\(mode>>1\)&1\)==1\) \) {) p
(//Alarm time) c n
(          a_hrs_mil += inc_dec2;) p
(//incremetn hours military) c n
(          a_hrs_std += inc_dec2;) p
(//increment hours standard) c n
(          ) p
(if) K
( \(a_hrs_mil == 24\) {) p n
(            a_hrs_mil = 0;) S
(//reset military time hours) c n
(lab4_ml.c) (Page 8/12) (Nov 15, 19 16:17) title
border
grestore
(Printed by Manuel Lopez) rhead
(lab4_ml.c) (4/6) (Friday November 15, 2019) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(          }) p n
(          ) S
(if) K
( \(a_hrs_std == 13\) {) p n
(            a_hrs_std = 1;) S
(//reset standard time hours) c n
(          }) p n
(        }) N
(        encoder1_past = encoder1_present;) N
(      }) S
(else) K
( ) p
(if) K
( \(encoder1_past == 2 \) {) p
(//past state 10) c n
(        ) p
(if) K
( \(\(\(mode&1\)==1\) && \(\(\(mode>>1\)&1\)==0\) \) {) p
(//clock time) c n
(          hrs_mil -= inc_dec2;) p
(//decrement hours military) c n
(          hrs_std -= inc_dec2;) p
(//decrement hours standard) c n
(          ) p
(if) K
( \(hrs_mil < 0\) {) p n
(            hrs_mil = 23;) S
(//reset military time hours) c n
(          }) p n
(          ) S
(if) K
( \(hrs_std <1\) {) p n
(            hrs_std = 12;) S
(//reset standard time hours) c n
(          }) p n
(        }) S
(else) K
( ) p
(if) K
( \(\(\(mode&1\)==0\) && \(\(\(mode>>1\)&1\)==1\)\) {) p
(//Alarm time) c n
(          a_hrs_mil -= inc_dec2;) p
(//decrement hours military) c n
(          a_hrs_std -= inc_dec2;) p
(//decrement hours standard) c n
(          ) p
(if) K
( \(a_hrs_mil < 0\) {) p n
(            a_hrs_mil = 23;) S
(//reset military time hours) c n
(          }) p n
(          ) S
(if) K
( \(a_hrs_std <1\) {) p n
(            a_hrs_std = 12;) S
(//reset standard time hours) c n
(          }) p n
(        }) N
(        encoder1_past = encoder1_present;) N
(      }) N
(      ) S
(break) K
(;) p n
(    ) S
(case) K
( 2:) p
(//encoder value 10) c n
(      ) p
(if) K
( \(encoder1_past == 3\) {) p
(//past value 11) c n
(        encoder1_past = encoder1_present;) p n
(      }) S
(else) K
( ) p
(if) K
( \(encoder1_past == 0\) {) p
(//past value 00) c n
(        encoder1_past = encoder1_present;) p n
(      }) N
(      ) S
(break) K
(;) p n
(    ) S
(case) K
( 0:) p
(//encoder value 00) c n
(      ) p
(if) K
( \(encoder1_past == 2\) {) p
(//past value 10) c n
(        encoder1_past = encoder1_present;) p n
(      }) S
(else) K
( ) p
(if) K
( \(encoder1_past == 1\) {) p
(//past value 01) c n
(        encoder1_past = encoder1_present;) p n
(      }) N
(      ) S
(break) K
(;) p n
(    ) S
(default) K
(:) p
(//nothing has changed) c n
(      hrs_mil +=0;) p
(//add nothing) c n
(      hrs_std +=0;) p
(//add nothing) c n
(      ) p
(break) K
(;) p n
(  }) N
() N
(//Update for encoder2 \(corse/ every locking position\)) c n
(//This updates MINUTES) N
(switch) K
( \(encoder2_present\) {) p n
(  ) S
(case) K
( 1:) p
(//current state is 01) c n
(    ) p
(if) K
( \(encoder2_past == 0\) {) p
(//past state 00) c n
(      encoder2_past = encoder2_present;) p n
(    }) S
(else) K
( ) p
(if) K
( \(encoder2_past == 3 \) {) p
(//curent state 11) c n
(      encoder2_past = encoder2_present;) p n
(    }) N
(    ) S
(break) K
(;) p n
(  ) S
(case) K
( 3:) p
(//curent state 11) c n
(    ) p
(if) K
( \(encoder2_past == 1\) {) p
(//past state 01\(increse\)) c n
(      ) p
(if) K
( \(\(\(mode&1\)==1\) && \(\(\(mode>>1\)&1\)==0\)\) {) p
(//clock time) c n
(        min_count += inc_dec1;) p
(//increment minutes) c n
(        ) p
(if) K
( \(min_count == 60\) {) p n
(          min_count = 0;) S
(//reset mins if over 59) c n
(        }) p n
(      }) S
(else) K
( ) p
(if) K
( \(\(\(mode&1\)==0\) && \(\(\(mode>>1\)&1\)==1\)\) {) p
(//Alarm time) c n
(        a_min_count += inc_dec1;) p
(//increment minutes) c n
(        ) p
(if) K
( \(a_min_count == 60\) {) p n
(lab4_ml.c) (Page 9/12) (Nov 15, 19 16:17) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(          a_min_count = 0;) p
(//reset mins if over 59) c n
(        }) p n
(      }) S
(else) K
( ) p
(if) K
(\(\(\(mode&1\)==0\)&& \(\(\(mode>>BIT1\)&1\)==0\)\){) p
(//volume control) c n
(        OCR3A++;) p
(//increase volume) c n
(      }) p n
(      encoder2_past = encoder2_present;) N
(    }) S
(else) K
( ) p
(if) K
( \(encoder2_past == 2 \) {) p
(//past state 10\(decrese\)) c n
(      ) p
(if) K
( \(\(\(mode&1\)==1\) && \(\(\(mode>>1\)&1\)==0\)\) {) p
(//clock time) c n
(        min_count -= inc_dec1;) p
(//decrement minutes) c n
(        ) p
(if) K
( \(min_count < 0\) {) p n
(          min_count = 59;) S
(//Zero to 59 mins) c n
(        }) p n
(      }) S
(else) K
( ) p
(if) K
( \(\(\(mode&1\)==0\) && \(\(\(mode>>1\)&1\)==1\)\) {) p
(// Alarm time) c n
(        a_min_count -= inc_dec1;) p
(//decrement minutes) c n
(        ) p
(if) K
( \(a_min_count < 0\) {) p n
(          a_min_count = 59;) S
(//Zero to 59 mins) c n
(        }) p n
(      }) S
(else) K
( ) p
(if) K
(\(\(\(mode&1\)==0\)&& \(\(\(mode>>BIT1\)&1\)==0\)\){) p
(//volume control) c n
(        OCR3A--;) p
(//decrease volume) c n
(      }) p n
(      encoder2_past = encoder2_present;) N
(    }) N
(    ) S
(break) K
(;) p n
(  ) S
(case) K
( 2:) p
(//current state 10) c n
(    ) p
(if) K
( \(encoder2_past == 3\) {) p
(//past state 11) c n
(      encoder2_past = encoder2_present;) p n
(    }) S
(else) K
( ) p
(if) K
( \(encoder2_past == 0\) {) p
(//past state 00) c n
(      encoder2_past = encoder2_present;) p n
(    }) N
(    ) S
(break) K
(;) p n
(  ) S
(case) K
( 0:) p
(//curent state 00) c n
(    ) p
(if) K
( \(encoder2_past == 2\) {) p
(//past state 10) c n
(      encoder2_past = encoder2_present;) p n
(    }) S
(else) K
( ) p
(if) K
( \(encoder2_past == 1\) {) p
(//past state 01) c n
(      encoder2_past = encoder2_present;) p n
(    }) N
(    ) S
(break) K
(;) p n
(  ) S
(default) K
(:) p
(//nothing has changed) c n
(    min_count +=0;) p
(//add nothing) c n
(    ) p
(break) K
(;) p n
(  }) N
() N
() N
(}) N
() N
() N
(//***********************************************************************) c n
(//                     ISR for timer counter TWO) N
(//***********************************************************************) N
(ISR\(TIMER2_OVF_vect\){) p n
(  ) S
(//Store PORT values to be able to restore) c n
(  PORTA_previous =PINA;) p
(//save PORTA values) c n
(  PORTC_previous = PINC;) p
(//save PORTC values) c n
() p n
(  update_mode\(\);) S
(//update Bar graph) c n
(  mil_std = \(mode>>2\) & 0x01;) p
(//Set to military or standard) c n
(  read_encoders\(\);) p
(//read encoders) c n
() p n
(  ) S
(//restore PORT A and C values) c n
(  DDRA = 0xFF;) p
(//outside of ISR, always output) c n
(  PORTA = PORTA_previous;) p
(//restore PORTA) c n
(  PORTC = PORTC_previous;) p
(//restore PORTC) c n
() p n
(}) N
() N
(//***********************************************************************) c n
(//                            spi_init) N
(//**********************************************************************) N
(void) k
( spi_init\() p
(void) k
(\){) p n
(lab4_ml.c) (Page 10/12) (Nov 15, 19 16:17) title
border
grestore
(Printed by Manuel Lopez) rhead
(lab4_ml.c) (5/6) (Friday November 15, 2019) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  SPCR   = \(1<<SPE\) | \(1<<MSTR\) ; ) p
(//master mode, clk low on idle, leading edge s) c n
(ample) N
(  SPSR   = \(1<<SPI2X\); ) p
(//choose double speed operation) c n
( }) p n
() N
(/***************************************************************) c n
(Function: display_mode\(\)) N
(Description:) N
(  This function will display the mode on the bargraph using the) N
(  SPI protocol) N
(Parameters: NONE) N
(Return:void) N
(***************************************************************/) N
(void) k
( display_mode\(\){) p n
(  SPDR = mode;) S
(//write value to register) c n
(  ) p
(while) K
(\(bit_is_clear\(SPSR,SPIF\)\){}) p
(//wait until data is sent) c n
(  PORTB ^=\(1<<BIT0\);) p
(//send rising edge to regclk on HC595) c n
(  PORTB ^=\(1<<BIT0\);) p
(//send falling edge to reglck on HC595) c n
(}) p n
() N
(  ) S
(/***************************************************************) c n
(  Function: init_ports\(\)) N
(  Description:) N
(    This function will set the correct bits used for the LCD) N
(    display to work correctly) N
(  Parameters: NONE) N
(  Return:void) N
(  ***************************************************************/) N
(  ) p
(void) k
( lcd_ports\(\){) p n
(    DDRF  |= 0x08;  ) S
(//port F bit 3 is enable for LCD) c n
(    PORTF &= 0xF7;  ) p
(//port F bit 3 is initially low) c n
(  }) p n
() N
() N
(int) k
( main\(\)) p n
({) N
(  init_tcnt0\(\);) S
(//initalize timer/counter 0) c n
(  init_tcnt2\(\);) p
(//initalize timer/counter 2) c n
(  init_tcnt1\(\);) p
(//initialize timer/coutner 1) c n
(  init_tcnt3\(\);) p
(//initialize timer/counter 3) c n
(  adc_init\(\);) p
(//initalize ADC) c n
(  sei\(\);) p
(//enable global interruts) c n
(  lcd_ports\(\);) p
(//initalize LCD ports) c n
(  ) p
(//DDRB shoudl equal 0xC7,0xE7 for testing \(EN pin5 led for testing\)) c n
(  DDRB = 0xE7;) p
(//PORTB ouput: ss\(pb0\), MOSI\(pb2\), sclk\(pb1\), OE_EN\(pb6\), PWM\(pb7\)) c n
(  spi_init\(\);) p
(//initialize SPI) c n
(  lcd_init\(\);) p n
(  clear_display\(\);) N
(  DDRC = 0x70;) S
(//set PORTC\(4\(SEL0\),5\(SEL1\),6\(SEL2\)\) as output \(never changes\)) c n
(  DDRE = 0xC8;) p
(//set PORTE PIN 6,7,3 as ouputs\(never changes\)) c n
(  PORTE =0xC0;) p
(//set SH/LD and CLK_INH high \(low enabled\)) c n
(  DDRD = 0x1;) p
(//set pin 0 on PORTD as output) c n
(  uint8_t digit_sel = 0;) p
(//digit select) c n
(  segment_data[2] =0xFC;) p
(//initalize colon ON) c n
() p n
(  ) S
(while) K
( \(1\) {) p n
(    _delay_ms\(2\);) N
(    decode_time\(\);) S
(//break up the time to 4, BCD digits in the array) c n
(    display_mode\(\);) p
(//display mode on bargraph) c n
() p n
(    ) S
(if) K
( \(digit_sel>4\) {) p
(//bound diigit select 0-4) c n
(      digit_sel =0;) p n
(    }) N
(    DDRA = 0xFF;) S
(//make PORTA output for Seven Segment) c n
(    PORTA = segment_data[digit_sel];) p
(//send 7 segment code to LED segments) c n
(    ) p
(//send PORTC the digit to display & power ON to seven seg\(bit7=0\)) c n
(    ) p
(if) K
( \(digit_sel == 0\) {) p n
(      PORTC = 0b01000000;) S
(//Hours Tens digit) c n
(    }) p
(else) K
( ) p
(if) K
( \(digit_sel==1\) {) p n
(lab4_ml.c) (Page 11/12) (Nov 15, 19 16:17) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      PORTC = 0b00110000;) p
(//Hours Ones  digit) c n
(    }) p
(else) K
( ) p
(if) K
( \(digit_sel==2\) {) p n
(      PORTC = 0b00100000;) S
(//colon digit) c n
(    }) p
(else) K
( ) p
(if) K
( \(digit_sel==3\) {) p n
(      PORTC = 0b00010000;) S
(//Minsutes tens digit) c n
(    }) p
(else) K
( ) p
(if) K
( \(digit_sel==4\) {) p n
(      PORTC =0b00000000;) S
(//Minutes ones digit) c n
(    }) p n
(    digit_sel++;) S
(//update digit to display\(increment\)) c n
(  }) p n
() N
(  ) S
(return) K
( 0;) p n
(}) N
(lab4_ml.c) (Page 12/12) (Nov 15, 19 16:17) title
border
grestore
(Printed by Manuel Lopez) rhead
(lab4_ml.c) (6/6) (Friday November 15, 2019) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
